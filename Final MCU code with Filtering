/*
 * BMET2922 Wearable PPG â€“ ESP32 Bluetooth SPP sender (Final, Min/Max Threshold for Plotter)
 *   - Serial plotter output: raw + min/max threshold (for visual adaptation)
 *   - Advanced filtering/EMA+std threshold for beat detection/BPM (unchanged)
 *   - Bluetooth NDJSON packets for BMET2922 Python GUI
 *   - BT LED blinks when disconnected, solid when connected
 *   - REC LED on only when recording
 *   - Button toggles recording (debounced)
 */
#include <Arduino.h>
#include "BluetoothSerial.h"

BluetoothSerial SerialBT;

// ============ Hardware pins ============
#define PIN_ADC     26      // Pulse sensor analog input
#define PIN_BTN     35      // Button input 
#define PIN_LED_BT  33      // Bluetooth status LED
#define PIN_LED_REC 32      // Recording status LED

#define DEVICE_NAME "ESP32_PPG"

// ========== Signal processing ========== 
#define SAMPLE_HZ        50
#define PKT_HZ           1
#define BPM_BROADCAST_HZ 5
#define DEBOUNCE_MS      30
#define MIN_PEAK_INTERVAL  300
#define MAX_PEAK_INTERVAL  2000
#define HP_CUTOFF_HZ     0.3f
#define LP_CUTOFF_HZ     5.0f
#define EMA_WINDOW_SEC   5.0f
#define THR_K            1.0f
#define LOW_AMP_THRESH   40

static char jsonBuf[640], tmpBuf[48];
volatile uint16_t seq = 0;
uint32_t lastSampleMs = 0, lastPktMs = 0, lastBpmMs = 0;
int samples[50], sampIdx = 0;

// Filtering state
float dt_s = 1.0f / SAMPLE_HZ, a_hp = 0.0f, hp_y_prev = 0.0f, hp_x_prev = 0.0f;
float a_lp = 0.0f, lp_y_prev = 0.0f;

// EMA state
float emaMean = NAN, emaVar = 0.0f, emaAlpha = 0.0f;

// Beat detection
float filtPrev = 0.0f; bool aboveThr = false;
float candPeak = 0.0f; uint32_t candStartMs = 0, lastPeakMs = 0;
float filtMin =  1e9f, filtMax = -1e9f;

// Button, LED, and recording state
int btnStable = HIGH, btnLastReading = HIGH;
uint32_t btnLastChangeMs = 0;
bool recording = false;

// Min/max adaptive threshold for plotting
static int runningMin = 4095, runningMax = 0;

// Helper: Read pulse sensor value
static inline int read_ppg() { return analogRead(PIN_ADC); }

// Helper: Write NDJSON to Bluetooth SPP
static inline void bt_write_line(const char* s) {
  SerialBT.write((const uint8_t*)s, strlen(s));
  SerialBT.write('\n');
}

// Helper: Update EMA mean/variance
static inline void ema_update(float x) {
  if (isnan(emaMean)) { emaMean = x; emaVar = 0.0f; return; }
  float d = x - emaMean;
  emaMean += emaAlpha * d;
  emaVar   = (1.0f - emaAlpha) * emaVar + emaAlpha * d * d;
}

void setup() {
  Serial.begin(115200);
  analogReadResolution(12);    // 12-bit ADC range
  analogSetAttenuation(ADC_11db); // Wide voltage input

  pinMode(PIN_BTN,     INPUT_PULLUP);
  pinMode(PIN_LED_BT,  OUTPUT);
  pinMode(PIN_LED_REC, OUTPUT);
  digitalWrite(PIN_LED_BT, LOW);
  digitalWrite(PIN_LED_REC, LOW);

  float RC_hp = 1.0f / (2.0f * PI * HP_CUTOFF_HZ);
  a_hp = RC_hp / (RC_hp + dt_s);

  float RC_lp = 1.0f / (2.0f * PI * LP_CUTOFF_HZ);
  a_lp = RC_lp / (RC_lp + dt_s);

  int windowN = (int)(EMA_WINDOW_SEC * SAMPLE_HZ);
  if (windowN < 1) windowN = 1;
  emaAlpha = 2.0f / (windowN + 1.0f);

  if (!SerialBT.begin(DEVICE_NAME))
    Serial.println("BT failed to connect.");
  else
    Serial.print("BT ready: "), Serial.println(DEVICE_NAME);

  lastSampleMs = lastPktMs = lastBpmMs = millis();
  randomSeed(esp_random());
}

void loop() {
  uint32_t now = millis();

  // --- Button debounce and recording toggle logic ---
  int reading = digitalRead(PIN_BTN);
  if (reading != btnLastReading) {
    btnLastChangeMs = now;
    btnLastReading  = reading;
  }
  if ((now - btnLastChangeMs) > DEBOUNCE_MS) {
    if (reading != btnStable) {
      btnStable = reading;
      if (btnStable == LOW) // Active low
        recording = !recording;
    }
  }

  // --- Bluetooth LED logic: blink if not connected, solid when connected ---
  if (SerialBT.hasClient()) {
    digitalWrite(PIN_LED_BT, HIGH);
  } else {
    static uint32_t lastBlink = 0; static bool blinkState = false;
    if (millis() - lastBlink > 500) {
      lastBlink = millis();
      blinkState = !blinkState;
      digitalWrite(PIN_LED_BT, blinkState ? HIGH : LOW);
    }
  }
  // --- REC LED logic: ON only when recording (solid), OFF otherwise ---
  digitalWrite(PIN_LED_REC, recording ? LOW : HIGH);

  // === Signal processing and sampling ===
  if (now - lastSampleMs >= (1000 / SAMPLE_HZ)) {
    lastSampleMs += (1000 / SAMPLE_HZ);

    int vRaw = read_ppg();
    samples[sampIdx] = vRaw;
    sampIdx = (sampIdx + 1) % 50;

    // Band-pass filtering (HP then LP)
    float x = (float)vRaw;
    float hp_y = a_hp * (hp_y_prev + x - hp_x_prev);
    hp_x_prev = x; hp_y_prev = hp_y;
    float y = a_lp * lp_y_prev + (1.0f - a_lp) * hp_y;
    lp_y_prev = y;

    // For amplitude over 1 sec
    if (y < filtMin) filtMin = y;
    if (y > filtMax) filtMax = y;

    // --- Min/max threshold calculation for Serial Plotter (visual only) ---
    if (vRaw < runningMin) runningMin = vRaw;
    if (vRaw > runningMax) runningMax = vRaw;
    int thresholdRaw = (int)(runningMin * 0.4 + runningMax * 0.6);

    // Serial Plotter output (raw signal, min/max adaptive threshold)
    Serial.print(vRaw);
    Serial.print(",");
    Serial.println(thresholdRaw);

    // --- Reset min/max every second ---
    if (sampIdx == 0) { // Every 50 samples (approx 1s)
      runningMin = 4095;
      runningMax = 0;
    }

    // --- Advanced threshold and peak detection (filtered, for BPM only) ---
    ema_update(y);
    float stdE = sqrtf(max(emaVar, 1e-6f));
    float thr  = emaMean + THR_K * stdE;

    float dv = y - filtPrev;
    if (!aboveThr && (y >= thr) && (dv > 0)) {
      aboveThr = true, candPeak = y, candStartMs = now;
    } else if (aboveThr) {
      if (y > candPeak) candPeak = y;
      if ((dv <= 0) || (now - candStartMs > MAX_PEAK_INTERVAL)) {
        uint32_t dt = now - lastPeakMs;
        if (dt > MIN_PEAK_INTERVAL && dt < MAX_PEAK_INTERVAL) {
          float currBpm = 60000.0f / dt;
          static float bpmLPF = NAN;
          if (isnan(bpmLPF)) bpmLPF = currBpm;
          else bpmLPF = bpmLPF + 0.3f * (currBpm - bpmLPF);
          lastPeakMs = now;
        }
        aboveThr = false;
      }
    }
    filtPrev = y;
  }

  // --- BPM state for broadcasting ---
  static float bpmInst = NAN, bpmLPF = NAN;
  {
    static uint32_t lastSeenPeak = 0, prevPeak = 0;
    if (lastPeakMs != 0 && lastPeakMs != lastSeenPeak) {
      if (prevPeak != 0) {
        uint32_t dt = lastPeakMs - prevPeak;
        if (dt > MIN_PEAK_INTERVAL && dt < MAX_PEAK_INTERVAL) {
          float currBpm = 60000.0f / dt;
          bpmInst = currBpm;
          if (isnan(bpmLPF)) bpmLPF = currBpm;
          else bpmLPF = bpmLPF + 0.3f * (currBpm - bpmLPF);
        }
      }
      prevPeak = lastPeakMs;
      lastSeenPeak = lastPeakMs;
    } else if (lastPeakMs && (millis() - lastPeakMs > MAX_PEAK_INTERVAL)) {
      bpmInst = NAN;
    }
  }

  // --- 5 Hz NDJSON BPM-only ---
  if (now - lastBpmMs >= (1000 / BPM_BROADCAST_HZ)) {
    lastBpmMs += (1000 / BPM_BROADCAST_HZ);
    float outBpm = isnan(bpmLPF) ? 0.0f : bpmLPF;
    int n = snprintf(jsonBuf, sizeof(jsonBuf), "{\"bpm\":%.1f}", outBpm);
    if (n > 0 && n < (int)sizeof(jsonBuf)) bt_write_line(jsonBuf);
  }

  // --- 1 Hz NDJSON full packet ---
  if (now - lastPktMs >= (1000 / PKT_HZ)) {
    lastPktMs += (1000 / PKT_HZ);
    uint16_t flags = 0;
    if (btnStable == LOW)                  flags |= 0x01; // Button pressed
    if ((filtMax - filtMin) < LOW_AMP_THRESH) flags |= 0x02; // Low amplitude
    if (recording)                         flags |= 0x04; // REC LED status

    float outBpm = isnan(bpmLPF) ? 0.0f : bpmLPF;
    int written = snprintf(jsonBuf, sizeof(jsonBuf), "{\"bpm\":%.1f,\"samples\":[", outBpm);
    if (written <= 0 || written >= (int)sizeof(jsonBuf)) return;

    int start = sampIdx;
    for (int i = 0; i < 50; ++i) {
      int idx = (start + i) % 50;
      int v = samples[idx];
      int n = snprintf(tmpBuf, sizeof(tmpBuf), (i == 49) ? "%d" : "%d,", v);
      if (written + n + 64 >= (int)sizeof(jsonBuf)) break;
      memcpy(jsonBuf + written, tmpBuf, n);
      written += n;
    }
    int n = snprintf(jsonBuf + written, sizeof(jsonBuf) - written, "],\"seq\":%u,\"flags\":%u,\"t_mcu\":%lu}", seq, flags, (unsigned long)now);
    if (n > 0) { bt_write_line(jsonBuf); seq++; }
    filtMin =  1e9f; filtMax = -1e9f;
  }
}
